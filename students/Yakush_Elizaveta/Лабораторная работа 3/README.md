# Лабораторная работа 3: Docker, Docker Compose и Portainer

## Студент: Yakush Elizaveta

---

## Задача 1: Создание и публикация custom-nginx образа

### Установка Docker и Docker Compose

<img width="913" height="806" alt="Снимок экрана 2025-11-20 в 15 13 00" src="https://github.com/user-attachments/assets/36804abb-a67f-4209-9078-11179aaeedf6" />
<img width="882" height="587" alt="Снимок экрана 2025-11-20 в 15 14 48" src="https://github.com/user-attachments/assets/4a04664c-c2ec-4974-9011-87bc5b6a5f51" />

 Сначала я обновила список пакетов в системе при помощи команды sudo apt update, чтобы получить актуальную информацию о доступных обновлениях и программах. Затем я установила необходимые вспомогательные утилиты: ca-certificates, curl, gnupg и lsb-release. Эти пакеты нужны для безопасного подключения к репозиторию Docker и корректного определения версии системы. После этого я добавила официальный репозиторий Docker в список источников пакетов, чтобы иметь возможность установить актуальную версию Docker не из стандартного Debian-репозитория. Затем я снова выполнила обновление списка пакетов — теперь система увидела новые пакеты Docker из добавленного репозитория.
Далее я установила Docker Engine, Docker CLI, компонент containerd, а также плагины buildx и Docker Compose. После завершения установки я проверила версии Docker и Docker Compose, чтобы убедиться, что установка прошла успешно. Затем я создала файл конфигурации /etc/docker/daemon.json и записала в него настройки зеркал для получения образов, после чего перезапустила службу Docker, чтобы изменения вступили в силу.
После настройки Docker я выполнила авторизацию в Docker Hub, чтобы можно было загружать туда свои контейнерные образы. Далее я скачала официальный образ nginx версии 1.21.1 с помощью команды docker pull. После этого создала директорию custom-nginx и перешла в неё, там создала файл index.html с собственным содержимым веб-страницы, затем создала Dockerfile, в котором настроила замену стандартной страницы nginx на мой файл.
После подготовки файлов я выполнила сборку собственного контейнерного образа на основе nginx и присвоила ему имя и тег elizansk1/custom-nginx:1.0.0. По завершении сборки я запустила контейнер на своём сервере, пробросив порт 80 контейнера на внешний порт 8080. В результате был запущен веб-сервер nginx с изменённой стартовой страницей, которую можно просматривать через браузер.

### ссылка на страницу моего репозитория https://hub.docker.com/repository/docker/elizansk1/custom-nginx/general
 
## Задача 2  Работа с контейнером custom-nginx:

<img width="1112" height="112" alt="Снимок экрана 2025-11-20 в 15 32 45" src="https://github.com/user-attachments/assets/bbb932f4-2f3f-46bd-b51a-e097e708ab16" />
<img width="1011" height="79" alt="Снимок экрана 2025-11-20 в 15 35 05" src="https://github.com/user-attachments/assets/50e15ea7-f4b0-4300-b729-383a78e6e756" />
<img width="1007" height="312" alt="Снимок экрана 2025-11-20 в 15 36 08" src="https://github.com/user-attachments/assets/ce916c93-1b64-49b4-bb86-d90f7e2c605c" />

После сборки образа я перешла к его запуску. Я запустила контейнер с использованием моего собственного образа elizansk1/custom-nginx:1.0.0, указав проброс порта: порт 80 внутри контейнера был связан с портом 8080 на локальном компьютере. Также я задала контейнеру имя при запуске. Контейнер был запущен в фоновом режиме. После старта я с помощью команды docker ps убедилась, что контейнер успешно работает и отображается в списке запущенных контейнеров.
Далее я выполнила переименование контейнера, чтобы его имя соответствовало заданным требованиям. После изменения имени я снова проверила список запущенных контейнеров, чтобы убедиться, что новое имя отображается корректно.
Затем я выполнила серию команд: проверила текущую дату, убедилась, что контейнер активно работает, просмотрела сетевые подключения на порту 8080, вывела логи контейнера, а также убедилась, что файл index.html действительно находится внутри контейнера и содержит корректные данные, выполнив его вывод в формате base64. В логах nginx была видна запись о запуске рабочих процессов, что также подтверждало успешную работу веб-сервера.
После этого я дополнительно проверила доступность веб-страницы извне. Для этого я отправила HTTP-запрос через curl на адрес http://127.0.0.1:8080 и получила HTML-страницу с изменённым содержимым: «Hey, ZGU!» и «I will be IT Engineer!». Это подтвердило, что nginx действительно использует новую главную страницу, которую я создала и добавила в свой кастомный Docker-образ.

## Задача 3:

### Узнаём, как подключиться к контейнеру

Используем docker help:
docker help attach
Команда docker attach позволяет подключиться к контейнеру, чтобы видеть его stdout, stderr и при необходимости вводить команды через stdin.

<img width="605" height="187" alt="Снимок экрана 2025-11-20 в 15 38 59" src="https://github.com/user-attachments/assets/c9a19d15-8d9d-4003-8a21-208c46d45b73" />
<img width="1029" height="67" alt="Снимок экрана 2025-11-20 в 15 40 05" src="https://github.com/user-attachments/assets/305e4da2-4fed-4b37-89e5-992e2e1c424a" />

я попробовала подключиться к своему контейнеру custom-nginx-t2 с помощью команды docker attach. Во время подключения я нажала комбинацию клавиш Ctrl + C, что отправило сигнал SIGINT и привело к корректному завершению работы nginx внутри контейнера. В логах отобразилось завершение рабочих процессов, и контейнер остановился.

<img width="821" height="388" alt="Снимок экрана 2025-11-20 в 15 42 54" src="https://github.com/user-attachments/assets/f20f913c-39b8-4d3e-bc2f-684c75618333" />

Я проверила статус контейнера командой docker ps -a — он действительно оказался в состоянии Exited. Далее я решила попасть внутрь остановленного контейнера с помощью docker exec -it custom-nginx-t2 bash. Попробовала выполнить apt-get update, но в контейнере оказались устаревшие репозитории, из-за чего пакетный менеджер не смог обновить списки пакетов. Аналогичная проблема возникла при попытке установить редактор nano, — система не смогла найти пакет.

файл /etc/nginx/conf.d/default.conf был отредактирован 

<img width="382" height="176" alt="Снимок экрана 2025-11-20 в 16 58 02" src="https://github.com/user-attachments/assets/04de3c81-7866-41d2-9dcc-a1bcafdb4fa8" />
<img width="666" height="444" alt="Снимок экрана 2025-11-20 в 17 01 44" src="https://github.com/user-attachments/assets/74df6827-7721-44d2-96e6-b0a22cbad7da" />

После редактирования я перезапустила nginx через команду nginx -s reload. Теперь веб-сервер внутри контейнера стал доступен по порту 81, что я проверила командой curl http://127.0.0.1:81. В ответ вернулась моя пользовательская HTML-страница с текстом «Hey, ZGU!» и «I will be IT Engineer!».

<img width="686" height="111" alt="Снимок экрана 2025-11-20 в 17 36 49" src="https://github.com/user-attachments/assets/75aad104-1b6f-42d3-a6dc-7cd742a8a2ef" />
<img width="445" height="23" alt="Снимок экрана 2025-11-20 в 18 29 48" src="https://github.com/user-attachments/assets/b2f8cbb1-be64-4b9a-bd70-2ff09cea7e48" />

Также я проверила, что проброс порта контейнера остался на хост: 80→8080. Это можно увидеть через docker port custom-nginx-t2. Но так как nginx больше не слушает порт 80, запрос на http://127.0.0.1:8080 стал возвращать ошибку соединения. Это логично, потому что порт на хосте больше не связан с работающим портом внутри контейнера.
В завершение я принудительно удалила контейнер с помощью docker rm -f custom-nginx-t2, чтобы освободить ресурсы и подготовить систему к дальнейшей работе.

## Задача 4:

<img width="1092" height="915" alt="Снимок экрана 2025-11-20 в 18 20 45" src="https://github.com/user-attachments/assets/0e303db9-6263-4e5a-bd4d-099c8efe88a3" />

После выполнения работы с образом nginx я приступила к следующему этапу — изучению работы с Docker-контейнерами и примонтированными томами.
Сначала я создала контейнер на базе CentOS. При этом был использован параметр -v $(pwd):/data, который монтирует текущую директорию хоста внутрь контейнера по пути /data. Так как образ CentOS ещё не был загружен, Docker автоматически скачал его из Docker Hub. Контейнер был запущен в фоновом режиме с бесконечной командой sleep infinity.
Затем аналогичным образом я создала второй контейнер на базе Debian — также в режиме sleep infinity и с тем же примонтированным volume.
Проверив контейнеры через docker ps, я убедилась, что оба они работают.
После этого подключилась внутрь CentOS-контейнера с помощью команды docker exec -it centos-container bash и создала внутри примонтированной директории /data файл file1.txt, записав в него слово "CentOS". Я вышла из контейнера и убедилась, что этот файл появился в файловой системе хост-машины.
Далее я создала на хосте ещё один файл — file2.txt, и также проверила его наличие внутри Debian-контейнера. После входа в него через docker exec -it debian_container bash я убедилась, что в директории /data доступны оба файла: созданный внутри CentOS-контейнера (file1.txt) и созданный на хосте (file2.txt). Их содержимое успешно отображается командами cat.
Таким образом, я проверила работу Docker volume с общим каталогом: изменения, выполненные на хосте, доступны в контейнерах, и наоборот.

## Задача 5:
Во время выполнения задания я столкнулась с проблемой при работе с Docker Compose и Portainer. В файле compose.yaml использовалось описание сервиса с образом portainer/portainer-ce:latest. Из-за того, что тег latest скачивает самую новую версию, возникла несовместимость с установленной у меня версией Docker (версия 29). В результате Portainer не запускался корректно. Решение было найдено в официальном обсуждении на GitHub по адресу https://github.com/orgs/portainer/discussions/12926

<img width="722" height="446" alt="image" src="https://github.com/user-attachments/assets/36588ad3-6e4a-4196-a69d-a13e8c4c841f" />

Ошибка в файле, исправлено на скриншоте ниже

<img width="704" height="432" alt="image" src="https://github.com/user-attachments/assets/ceb107da-2890-46b5-99a8-8b49efbcaf51" />

<img width="702" height="524" alt="image" src="https://github.com/user-attachments/assets/42079eef-1677-416f-8864-7050d666103f" />

В данном случае приоритет будет у compose.yaml так команда docker compose up отдает приоритет compose.yaml файлу, а не docker-compose.yaml файлу. Для явного указания compose файла можно использовать команду docker compose -f docker-compose.yml 

<img width="2834" height="1720" alt="image" src="https://github.com/user-attachments/assets/8ab9d453-e0df-4d36-aec0-e45951af3ecc" />
<img width="2826" height="1738" alt="image" src="https://github.com/user-attachments/assets/6d34a96c-984c-4191-8dc7-36e91961c305" />
После исправлений контейнер Portainer успешно запустился, о чём свидетельствует вывод docker ps.
<img width="3136" height="2084" alt="image" src="https://github.com/user-attachments/assets/775abf0d-4800-4653-aca2-28e56d734a21" />
<img width="539" height="48" alt="Снимок экрана 2025-11-20 в 19 13 26" src="https://github.com/user-attachments/assets/12ac5279-7c37-476e-ae51-1ccc142f4797" />

Я создала рабочую директорию /tmp/ZGU/docker/task для выполнения задач с Docker Compose и Portainer. Внутри этой директории были созданы файлы compose.yaml и docker-compose.yaml. При попытке выполнить команду docker compose up появилось предупреждение о наличии нескольких конфигурационных файлов. Docker по умолчанию использовал compose.yaml.
При первом запуске файла compose.yaml возникла ошибка found unexpected end of stream, которая указывает на синтаксическую ошибку в YAML (например, неправильное количество пробелов или отсутствие завершающих отступов). Я исправила файл через редактор nano, после чего контейнер Portainer успешно подтянулся и запустился.
Также появилось предупреждение о том, что атрибут version устарел и будет игнорироваться, поэтому я его удалили, чтобы избежать путаницы. После исправлений и повторного запуска контейнер Portainer версии 2.20.2 успешно запустился.
Далее я подготовила локальный Docker Registry, пометила мой кастомный образ elizansk1/custom-nginx:1.0.0 тегом 127.0.0.1:5000/custom-nginx:latest и отправила его в локальный Registry с помощью команды docker push. Все слои образа были успешно загружены, о чём свидетельствовал вывод Docker.
Был удален docker-compose.yaml файл, при выполении команды docker compose up -d произошла ошибка, потому что файл compose.yaml внутри раздела include требует наличие docker-compose.yaml. Предложений от терминала не поступило(логично что нужно создать docker-compose.yaml)

<img width="2102" height="382" alt="image" src="https://github.com/user-attachments/assets/281d3e76-8930-4be4-829a-b8ff48ee65cf" />

Далее при попытке выполнить комманду docker down также была ошибка
 
<img width="1162" height="126" alt="image" src="https://github.com/user-attachments/assets/552df1ce-ae35-45d3-bb98-5e8d67e41433" />

После этого было удаление по compose.

<img width="2226" height="332" alt="image" src="https://github.com/user-attachments/assets/45bf4728-f2e8-476a-a6b8-a8eaa13bf3d2" />

# Вывод

В ходе выполнения лабораторной работы были изучены основные возможности Docker и Docker Compose, включая создание, модификацию и запуск контейнеров, работу с локальными и удалёнными образами, а также организацию стеков приложений через Compose-файлы.
Были выполнены следующие ключевые действия:
Установка Docker и Docker Compose на Linux-систему, проверка корректной работы сервисов.
Скачивание и модификация официального образа Nginx, создание Dockerfile для замены стандартной индекс-страницы, сборка собственного образа custom-nginx и загрузка его в Docker Hub и локальный Registry.
Создание и запуск контейнеров на базе образов CentOS, Debian и кастомного Nginx с использованием команд docker run и docker exec, работа с файловой системой контейнеров и проверка доступности сервисов через curl.
Настройка и запуск Portainer через Docker Compose, выявление и устранение ошибок, связанных с версией образа и устаревшим атрибутом version в YAML-файле.
Использование локального Registry для хранения и распространения собственного образа, работа с тегами и push/pull операций.
Разбор поведения Docker Compose при наличии нескольких конфигурационных файлов, а также ошибок при удалении файлов, на которые есть ссылки через include.









